import{k as Ht,l as Kt,m as Mt,n as Pt}from"./index-BLKp-oJf.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt(0),ht=BigInt(1),Ft=BigInt(2);function et(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function lt(n){if(!et(n))throw new Error("Uint8Array expected")}const Gt=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function st(n){lt(n);let e="";for(let t=0;t<n.length;t++)e+=Gt[n[t]];return e}function Lt(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function Bt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const P={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Nt(n){if(n>=P._0&&n<=P._9)return n-P._0;if(n>=P._A&&n<=P._F)return n-(P._A-10);if(n>=P._a&&n<=P._f)return n-(P._a-10)}function ct(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let i=0,c=0;i<t;i++,c+=2){const g=Nt(n.charCodeAt(c)),s=Nt(n.charCodeAt(c+1));if(g===void 0||s===void 0){const o=n[c]+n[c+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+c)}r[i]=g*16+s}return r}function nt(n){return Bt(st(n))}function xt(n){return lt(n),Bt(st(Uint8Array.from(n).reverse()))}function ft(n,e){return ct(n.toString(16).padStart(e*2,"0"))}function vt(n,e){return ft(n,e).reverse()}function Wt(n){return ct(Lt(n))}function M(n,e,t){let r;if(typeof e=="string")try{r=ct(e)}catch(c){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${c}`)}else if(et(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(`${n} expected ${t} bytes, got ${i}`);return r}function at(...n){let e=0;for(let r=0;r<n.length;r++){const i=n[r];lt(i),e+=i.length}const t=new Uint8Array(e);for(let r=0,i=0;r<n.length;r++){const c=n[r];t.set(c,i),i+=c.length}return t}function Xt(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function Dt(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Qt(n){let e;for(e=0;n>Ut;n>>=ht,e+=1);return e}function Jt(n,e){return n>>BigInt(e)&ht}function tn(n,e,t){return n|(t?ht:Ut)<<BigInt(e)}const St=n=>(Ft<<BigInt(n-1))-ht,wt=n=>new Uint8Array(n),Ot=n=>Uint8Array.from(n);function zt(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=wt(n),i=wt(n),c=0;const g=()=>{r.fill(1),i.fill(0),c=0},s=(...w)=>t(i,r,...w),o=(w=wt())=>{i=s(Ot([0]),w),r=s(),w.length!==0&&(i=s(Ot([1]),w),r=s())},u=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const q=[];for(;w<e;){r=s();const _=r.slice();q.push(_),w+=r.length}return at(...q)};return(w,q)=>{g(),o(w);let _;for(;!(_=q(u()));)o();return g(),_}}const nn={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||et(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function dt(n,e,t={}){const r=(i,c,g)=>{const s=nn[c];if(typeof s!="function")throw new Error(`Invalid validator "${c}", expected function`);const o=n[i];if(!(g&&o===void 0)&&!s(o,n))throw new Error(`Invalid param ${String(i)}=${o} (${typeof o}), expected ${c}`)};for(const[i,c]of Object.entries(e))r(i,c,!1);for(const[i,c]of Object.entries(t))r(i,c,!0);return n}const en=Object.freeze(Object.defineProperty({__proto__:null,abytes:lt,bitGet:Jt,bitLen:Qt,bitMask:St,bitSet:tn,bytesToHex:st,bytesToNumberBE:nt,bytesToNumberLE:xt,concatBytes:at,createHmacDrbg:zt,ensureBytes:M,equalBytes:Xt,hexToBytes:ct,hexToNumber:Bt,isBytes:et,numberToBytesBE:ft,numberToBytesLE:vt,numberToHexUnpadded:Lt,numberToVarBytesBE:Wt,utf8ToBytes:Dt,validateObject:dt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),T=BigInt(1),J=BigInt(2),rn=BigInt(3),pt=BigInt(4),$t=BigInt(5),_t=BigInt(8);BigInt(9);BigInt(16);function z(n,e){const t=n%e;return t>=R?t:e+t}function on(n,e,t){if(t<=R||e<R)throw new Error("Expected power/modulo > 0");if(t===T)return R;let r=T;for(;e>R;)e&T&&(r=r*n%t),n=n*n%t,e>>=T;return r}function Y(n,e,t){let r=n;for(;e-- >R;)r*=r,r%=t;return r}function mt(n,e){if(n===R||e<=R)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=z(n,e),r=e,i=R,c=T;for(;t!==R;){const s=r/t,o=r%t,u=i-c*s;r=t,t=o,i=c,c=u}if(r!==T)throw new Error("invert: does not exist");return z(i,e)}function sn(n){const e=(n-T)/J;let t,r,i;for(t=n-T,r=0;t%J===R;t/=J,r++);for(i=J;i<n&&on(i,e,n)!==n-T;i++);if(r===1){const g=(n+T)/pt;return function(o,u){const p=o.pow(u,g);if(!o.eql(o.sqr(p),u))throw new Error("Cannot find square root");return p}}const c=(t+T)/J;return function(s,o){if(s.pow(o,e)===s.neg(s.ONE))throw new Error("Cannot find square root");let u=r,p=s.pow(s.mul(s.ONE,i),t),w=s.pow(o,c),q=s.pow(o,t);for(;!s.eql(q,s.ONE);){if(s.eql(q,s.ZERO))return s.ZERO;let _=1;for(let f=s.sqr(q);_<u&&!s.eql(f,s.ONE);_++)f=s.sqr(f);const m=s.pow(p,T<<BigInt(u-_-1));p=s.sqr(m),w=s.mul(w,m),q=s.mul(q,p),u=_}return w}}function cn(n){if(n%pt===rn){const e=(n+T)/pt;return function(r,i){const c=r.pow(i,e);if(!r.eql(r.sqr(c),i))throw new Error("Cannot find square root");return c}}if(n%_t===$t){const e=(n-$t)/_t;return function(r,i){const c=r.mul(i,J),g=r.pow(c,e),s=r.mul(i,g),o=r.mul(r.mul(s,J),g),u=r.mul(s,r.sub(o,r.ONE));if(!r.eql(r.sqr(u),i))throw new Error("Cannot find square root");return u}}return sn(n)}const fn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function un(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=fn.reduce((r,i)=>(r[i]="function",r),e);return dt(n,t)}function an(n,e,t){if(t<R)throw new Error("Expected power > 0");if(t===R)return n.ONE;if(t===T)return e;let r=n.ONE,i=e;for(;t>R;)t&T&&(r=n.mul(r,i)),i=n.sqr(i),t>>=T;return r}function ln(n,e){const t=new Array(e.length),r=e.reduce((c,g,s)=>n.is0(g)?c:(t[s]=c,n.mul(c,g)),n.ONE),i=n.inv(r);return e.reduceRight((c,g,s)=>n.is0(g)?c:(t[s]=n.mul(c,t[s]),n.mul(c,g)),i),t}function Ct(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function dn(n,e,t=!1,r={}){if(n<=R)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:i,nByteLength:c}=Ct(n,e);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const g=cn(n),s=Object.freeze({ORDER:n,BITS:i,BYTES:c,MASK:St(i),ZERO:R,ONE:T,create:o=>z(o,n),isValid:o=>{if(typeof o!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);return R<=o&&o<n},is0:o=>o===R,isOdd:o=>(o&T)===T,neg:o=>z(-o,n),eql:(o,u)=>o===u,sqr:o=>z(o*o,n),add:(o,u)=>z(o+u,n),sub:(o,u)=>z(o-u,n),mul:(o,u)=>z(o*u,n),pow:(o,u)=>an(s,o,u),div:(o,u)=>z(o*mt(u,n),n),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>mt(o,n),sqrt:r.sqrt||(o=>g(s,o)),invertBatch:o=>ln(s,o),cmov:(o,u,p)=>p?u:o,toBytes:o=>t?vt(o,c):ft(o,c),fromBytes:o=>{if(o.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${o.length}`);return t?xt(o):nt(o)}});return Object.freeze(s)}function Vt(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function kt(n){const e=Vt(n);return e+Math.ceil(e/2)}function hn(n,e,t=!1){const r=n.length,i=Vt(e),c=kt(e);if(r<16||r<c||r>1024)throw new Error(`expected ${c}-1024 bytes of input, got ${r}`);const g=t?nt(n):xt(n),s=z(g,e-T)+T;return t?vt(s,i):ft(s,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gn=BigInt(0),yt=BigInt(1);function wn(n,e){const t=(i,c)=>{const g=c.negate();return i?g:c},r=i=>{const c=Math.ceil(e/i)+1,g=2**(i-1);return{windows:c,windowSize:g}};return{constTimeNegate:t,unsafeLadder(i,c){let g=n.ZERO,s=i;for(;c>gn;)c&yt&&(g=g.add(s)),s=s.double(),c>>=yt;return g},precomputeWindow(i,c){const{windows:g,windowSize:s}=r(c),o=[];let u=i,p=u;for(let w=0;w<g;w++){p=u,o.push(p);for(let q=1;q<s;q++)p=p.add(u),o.push(p);u=p.double()}return o},wNAF(i,c,g){const{windows:s,windowSize:o}=r(i);let u=n.ZERO,p=n.BASE;const w=BigInt(2**i-1),q=2**i,_=BigInt(i);for(let m=0;m<s;m++){const f=m*o;let l=Number(g&w);g>>=_,l>o&&(l-=q,g+=yt);const d=f,b=f+Math.abs(l)-1,B=m%2!==0,I=l<0;l===0?p=p.add(t(B,c[d])):u=u.add(t(I,c[b]))}return{p:u,f:p}},wNAFCached(i,c,g,s){const o=i._WINDOW_SIZE||1;let u=c.get(i);return u||(u=this.precomputeWindow(i,o),o!==1&&c.set(i,s(u))),this.wNAF(o,u,g)}}}function Yt(n){return un(n.Fp),dt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ct(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function yn(n){const e=Yt(n);dt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:i}=e;if(t){if(!r.eql(i,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:pn,hexToBytes:mn}=en,tt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=tt;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:pn(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=tt,t=typeof n=="string"?mn(n):n;lt(t);let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:i,l:c}=tt._parseInt(t.subarray(2)),{d:g,l:s}=tt._parseInt(c);if(s.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:g}},hexFromSig(n){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const p=u.toString(16);return p.length&1?`0${p}`:p},r=e(t(n.s)),i=e(t(n.r)),c=r.length/2,g=i.length/2,s=t(c),o=t(g);return`30${t(g+c+4)}02${o}${i}02${s}${r}`}},F=BigInt(0),j=BigInt(1);BigInt(2);const Tt=BigInt(3);BigInt(4);function bn(n){const e=yn(n),{Fp:t}=e,r=e.toBytes||((m,f,l)=>{const d=f.toAffine();return at(Uint8Array.from([4]),t.toBytes(d.x),t.toBytes(d.y))}),i=e.fromBytes||(m=>{const f=m.subarray(1),l=t.fromBytes(f.subarray(0,t.BYTES)),d=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:l,y:d}});function c(m){const{a:f,b:l}=e,d=t.sqr(m),b=t.mul(d,m);return t.add(t.add(b,t.mul(m,f)),l)}if(!t.eql(t.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function g(m){return typeof m=="bigint"&&F<m&&m<e.n}function s(m){if(!g(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function o(m){const{allowedPrivateKeyLengths:f,nByteLength:l,wrapPrivateKey:d,n:b}=e;if(f&&typeof m!="bigint"){if(et(m)&&(m=st(m)),typeof m!="string"||!f.includes(m.length))throw new Error("Invalid key");m=m.padStart(l*2,"0")}let B;try{B=typeof m=="bigint"?m:nt(M("private key",m,l))}catch{throw new Error(`private key must be ${l} bytes, hex or bigint, not ${typeof m}`)}return d&&(B=z(B,b)),s(B),B}const u=new Map;function p(m){if(!(m instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(f,l,d){if(this.px=f,this.py=l,this.pz=d,f==null||!t.isValid(f))throw new Error("x required");if(l==null||!t.isValid(l))throw new Error("y required");if(d==null||!t.isValid(d))throw new Error("z required")}static fromAffine(f){const{x:l,y:d}=f||{};if(!f||!t.isValid(l)||!t.isValid(d))throw new Error("invalid affine point");if(f instanceof w)throw new Error("projective point not allowed");const b=B=>t.eql(B,t.ZERO);return b(l)&&b(d)?w.ZERO:new w(l,d,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const l=t.invertBatch(f.map(d=>d.pz));return f.map((d,b)=>d.toAffine(l[b])).map(w.fromAffine)}static fromHex(f){const l=w.fromAffine(i(M("pointHex",f)));return l.assertValidity(),l}static fromPrivateKey(f){return w.BASE.multiply(o(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:f,y:l}=this.toAffine();if(!t.isValid(f)||!t.isValid(l))throw new Error("bad point: x or y not FE");const d=t.sqr(l),b=c(f);if(!t.eql(d,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){p(f);const{px:l,py:d,pz:b}=this,{px:B,py:I,pz:S}=f,y=t.eql(t.mul(l,S),t.mul(B,b)),E=t.eql(t.mul(d,S),t.mul(I,b));return y&&E}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:l}=e,d=t.mul(l,Tt),{px:b,py:B,pz:I}=this;let S=t.ZERO,y=t.ZERO,E=t.ZERO,v=t.mul(b,b),k=t.mul(B,B),$=t.mul(I,I),A=t.mul(b,B);return A=t.add(A,A),E=t.mul(b,I),E=t.add(E,E),S=t.mul(f,E),y=t.mul(d,$),y=t.add(S,y),S=t.sub(k,y),y=t.add(k,y),y=t.mul(S,y),S=t.mul(A,S),E=t.mul(d,E),$=t.mul(f,$),A=t.sub(v,$),A=t.mul(f,A),A=t.add(A,E),E=t.add(v,v),v=t.add(E,v),v=t.add(v,$),v=t.mul(v,A),y=t.add(y,v),$=t.mul(B,I),$=t.add($,$),v=t.mul($,A),S=t.sub(S,v),E=t.mul($,k),E=t.add(E,E),E=t.add(E,E),new w(S,y,E)}add(f){p(f);const{px:l,py:d,pz:b}=this,{px:B,py:I,pz:S}=f;let y=t.ZERO,E=t.ZERO,v=t.ZERO;const k=e.a,$=t.mul(e.b,Tt);let A=t.mul(l,B),C=t.mul(d,I),V=t.mul(b,S),G=t.add(l,d),a=t.add(B,I);G=t.mul(G,a),a=t.add(A,C),G=t.sub(G,a),a=t.add(l,b);let h=t.add(B,S);return a=t.mul(a,h),h=t.add(A,V),a=t.sub(a,h),h=t.add(d,b),y=t.add(I,S),h=t.mul(h,y),y=t.add(C,V),h=t.sub(h,y),v=t.mul(k,a),y=t.mul($,V),v=t.add(y,v),y=t.sub(C,v),v=t.add(C,v),E=t.mul(y,v),C=t.add(A,A),C=t.add(C,A),V=t.mul(k,V),a=t.mul($,a),C=t.add(C,V),V=t.sub(A,V),V=t.mul(k,V),a=t.add(a,V),A=t.mul(C,a),E=t.add(E,A),A=t.mul(h,a),y=t.mul(G,y),y=t.sub(y,A),A=t.mul(G,C),v=t.mul(h,v),v=t.add(v,A),new w(y,E,v)}subtract(f){return this.add(f.negate())}is0(){return this.equals(w.ZERO)}wNAF(f){return _.wNAFCached(this,u,f,l=>{const d=t.invertBatch(l.map(b=>b.pz));return l.map((b,B)=>b.toAffine(d[B])).map(w.fromAffine)})}multiplyUnsafe(f){const l=w.ZERO;if(f===F)return l;if(s(f),f===j)return this;const{endo:d}=e;if(!d)return _.unsafeLadder(this,f);let{k1neg:b,k1:B,k2neg:I,k2:S}=d.splitScalar(f),y=l,E=l,v=this;for(;B>F||S>F;)B&j&&(y=y.add(v)),S&j&&(E=E.add(v)),v=v.double(),B>>=j,S>>=j;return b&&(y=y.negate()),I&&(E=E.negate()),E=new w(t.mul(E.px,d.beta),E.py,E.pz),y.add(E)}multiply(f){s(f);let l=f,d,b;const{endo:B}=e;if(B){const{k1neg:I,k1:S,k2neg:y,k2:E}=B.splitScalar(l);let{p:v,f:k}=this.wNAF(S),{p:$,f:A}=this.wNAF(E);v=_.constTimeNegate(I,v),$=_.constTimeNegate(y,$),$=new w(t.mul($.px,B.beta),$.py,$.pz),d=v.add($),b=k.add(A)}else{const{p:I,f:S}=this.wNAF(l);d=I,b=S}return w.normalizeZ([d,b])[0]}multiplyAndAddUnsafe(f,l,d){const b=w.BASE,B=(S,y)=>y===F||y===j||!S.equals(b)?S.multiplyUnsafe(y):S.multiply(y),I=B(this,l).add(B(f,d));return I.is0()?void 0:I}toAffine(f){const{px:l,py:d,pz:b}=this,B=this.is0();f==null&&(f=B?t.ONE:t.inv(b));const I=t.mul(l,f),S=t.mul(d,f),y=t.mul(b,f);if(B)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}isTorsionFree(){const{h:f,isTorsionFree:l}=e;if(f===j)return!0;if(l)return l(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:l}=e;return f===j?this:l?l(w,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),r(w,this,f)}toHex(f=!0){return st(this.toRawBytes(f))}}w.BASE=new w(e.Gx,e.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const q=e.nBitLength,_=wn(w,e.endo?Math.ceil(q/2):q);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:o,weierstrassEquation:c,isWithinCurveOrder:g}}function En(n){const e=Yt(n);return dt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Bn(n){const e=En(n),{Fp:t,n:r}=e,i=t.BYTES+1,c=2*t.BYTES+1;function g(a){return F<a&&a<t.ORDER}function s(a){return z(a,r)}function o(a){return mt(a,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:p,weierstrassEquation:w,isWithinCurveOrder:q}=bn({...e,toBytes(a,h,x){const O=h.toAffine(),N=t.toBytes(O.x),Z=at;return x?Z(Uint8Array.from([h.hasEvenY()?2:3]),N):Z(Uint8Array.from([4]),N,t.toBytes(O.y))},fromBytes(a){const h=a.length,x=a[0],O=a.subarray(1);if(h===i&&(x===2||x===3)){const N=nt(O);if(!g(N))throw new Error("Point is not on curve");const Z=w(N);let U;try{U=t.sqrt(Z)}catch(H){const X=H instanceof Error?": "+H.message:"";throw new Error("Point is not on curve"+X)}const L=(U&j)===j;return(x&1)===1!==L&&(U=t.neg(U)),{x:N,y:U}}else if(h===c&&x===4){const N=t.fromBytes(O.subarray(0,t.BYTES)),Z=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:N,y:Z}}else throw new Error(`Point of length ${h} was invalid. Expected ${i} compressed bytes or ${c} uncompressed bytes`)}}),_=a=>st(ft(a,e.nByteLength));function m(a){const h=r>>j;return a>h}function f(a){return m(a)?s(-a):a}const l=(a,h,x)=>nt(a.slice(h,x));class d{constructor(h,x,O){this.r=h,this.s=x,this.recovery=O,this.assertValidity()}static fromCompact(h){const x=e.nByteLength;return h=M("compactSignature",h,x*2),new d(l(h,0,x),l(h,x,2*x))}static fromDER(h){const{r:x,s:O}=tt.toSig(M("DER",h));return new d(x,O)}assertValidity(){if(!q(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!q(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(h){return new d(this.r,this.s,h)}recoverPublicKey(h){const{r:x,s:O,recovery:N}=this,Z=E(M("msgHash",h));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const U=N===2||N===3?x+e.n:x;if(U>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const L=N&1?"03":"02",W=u.fromHex(L+_(U)),H=o(U),X=s(-Z*H),ut=s(O*H),D=u.BASE.multiplyAndAddUnsafe(W,X,ut);if(!D)throw new Error("point at infinify");return D.assertValidity(),D}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return ct(this.toDERHex())}toDERHex(){return tt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ct(this.toCompactHex())}toCompactHex(){return _(this.r)+_(this.s)}}const b={isValidPrivateKey(a){try{return p(a),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const a=kt(e.n);return hn(e.randomBytes(a),e.n)},precompute(a=8,h=u.BASE){return h._setWindowSize(a),h.multiply(BigInt(3)),h}};function B(a,h=!0){return u.fromPrivateKey(a).toRawBytes(h)}function I(a){const h=et(a),x=typeof a=="string",O=(h||x)&&a.length;return h?O===i||O===c:x?O===2*i||O===2*c:a instanceof u}function S(a,h,x=!0){if(I(a))throw new Error("first arg must be private key");if(!I(h))throw new Error("second arg must be public key");return u.fromHex(h).multiply(p(a)).toRawBytes(x)}const y=e.bits2int||function(a){const h=nt(a),x=a.length*8-e.nBitLength;return x>0?h>>BigInt(x):h},E=e.bits2int_modN||function(a){return s(y(a))},v=St(e.nBitLength);function k(a){if(typeof a!="bigint")throw new Error("bigint expected");if(!(F<=a&&a<v))throw new Error(`bigint expected < 2^${e.nBitLength}`);return ft(a,e.nByteLength)}function $(a,h,x=A){if(["recovered","canonical"].some(Q=>Q in x))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:N}=e;let{lowS:Z,prehash:U,extraEntropy:L}=x;Z==null&&(Z=!0),a=M("msgHash",a),U&&(a=M("prehashed msgHash",O(a)));const W=E(a),H=p(h),X=[k(H),k(W)];if(L!=null&&L!==!1){const Q=L===!0?N(t.BYTES):L;X.push(M("extraEntropy",Q))}const ut=at(...X),D=W;function gt(Q){const rt=y(Q);if(!q(rt))return;const It=o(rt),ot=u.BASE.multiply(rt).toAffine(),K=s(ot.x);if(K===F)return;const it=s(It*s(D+K*H));if(it===F)return;let At=(ot.x===K?0:2)|Number(ot.y&j),qt=it;return Z&&m(it)&&(qt=f(it),At^=1),new d(K,qt,At)}return{seed:ut,k2sig:gt}}const A={lowS:e.lowS,prehash:!1},C={lowS:e.lowS,prehash:!1};function V(a,h,x=A){const{seed:O,k2sig:N}=$(a,h,x),Z=e;return zt(Z.hash.outputLen,Z.nByteLength,Z.hmac)(O,N)}u.BASE._setWindowSize(8);function G(a,h,x,O=C){var ot;const N=a;if(h=M("msgHash",h),x=M("publicKey",x),"strict"in O)throw new Error("options.strict was renamed to lowS");const{lowS:Z,prehash:U}=O;let L,W;try{if(typeof N=="string"||et(N))try{L=d.fromDER(N)}catch(K){if(!(K instanceof tt.Err))throw K;L=d.fromCompact(N)}else if(typeof N=="object"&&typeof N.r=="bigint"&&typeof N.s=="bigint"){const{r:K,s:it}=N;L=new d(K,it)}else throw new Error("PARSE");W=u.fromHex(x)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Z&&L.hasHighS())return!1;U&&(h=e.hash(h));const{r:H,s:X}=L,ut=E(h),D=o(X),gt=s(ut*D),Q=s(H*D),rt=(ot=u.BASE.multiplyAndAddUnsafe(W,gt,Q))==null?void 0:ot.toAffine();return rt?s(rt.x)===H:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:S,sign:V,verify:G,ProjectivePoint:u,Signature:d,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function xn(n){return{hash:n,hmac:(e,...t)=>Ht(n,e,Kt(...t)),randomBytes:Mt}}function vn(n,e){const t=r=>Bn({...n,...xn(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Sn=BigInt(1),bt=BigInt(2),Rt=(n,e)=>(n+e/bt)/e;function In(n){const e=jt,t=BigInt(3),r=BigInt(6),i=BigInt(11),c=BigInt(22),g=BigInt(23),s=BigInt(44),o=BigInt(88),u=n*n*n%e,p=u*u*n%e,w=Y(p,t,e)*p%e,q=Y(w,t,e)*p%e,_=Y(q,bt,e)*u%e,m=Y(_,i,e)*_%e,f=Y(m,c,e)*m%e,l=Y(f,s,e)*f%e,d=Y(l,o,e)*l%e,b=Y(d,s,e)*f%e,B=Y(b,t,e)*p%e,I=Y(B,g,e)*m%e,S=Y(I,r,e)*u%e,y=Y(S,bt,e);if(!Et.eql(Et.sqr(y),n))throw new Error("Cannot find square root");return y}const Et=dn(jt,void 0,void 0,{sqrt:In}),An=vn({a:BigInt(0),b:BigInt(7),Fp:Et,n:Zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Zt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Sn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),c=t,g=BigInt("0x100000000000000000000000000000000"),s=Rt(c*n,e),o=Rt(-r*n,e);let u=z(n-s*t-o*i,e),p=z(-s*r-o*c,e);const w=u>g,q=p>g;if(w&&(u=e-u),q&&(p=e-p),u>g||p>g)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:w,k1:u,k2neg:q,k2:p}}}},Pt);BigInt(0);An.ProjectivePoint;export{An as secp256k1};
